### Basic Idea
- Our initial access to a remote server is usually in the context of a low-privileged user, which would not give us complete access over the box.
- Initially, we often find ourselves getting into a system as a low-privileged user.
- To get full access to the system to accomplish more, we need to escalate our privileges to the root/administrator user.
	-  `root` user on `Linux`
	- `administrator`/`SYSTEM` user on `Windows`
- We can do this by finding an internal/local vulnerability within the system, and do it that way.

### PrivEsc Checklists
- Once we get initial access, we need to scourge the system for potential vulnerabilities we can use.
- Many checklists and cheat sheets exist online for this purpose.
	-  [HackTricks](https://book.hacktricks.xyz) is a great one, along with [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)
- With these resources, we can get more familiar with the various commands/techniques in how we can use multiple weaknesses to escalate our privileges.

### Enumeration Scripts
- Typing the commands may work, but can be cumbersome. Luckily, we can automate the process by creating scripts that take advantage of these commands.
- Most popular enumeration scripts include:
	- [LinEnum](https://github.com/rebootuser/LinEnum.git) and [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker) for Linux systems
	- [Seatbelt](https://github.com/GhostPack/Seatbelt) and [JAWS](https://github.com/411Hall/JAWS) for Windows systems
- Another great suite is [Privilege Escalation Awesome Scripts SUITE (PEASS)](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite), which is always up to date and has scripts that will work on both Linux and Windows systems.
- 
> Note: These scripts will run many commands known for identifying vulnerabilities and create a lot of "noise" that may trigger anti-virus software or security monitoring software that looks for these types of events. This may prevent the scripts from running or even trigger an alarm that the system has been compromised. In some instances, we may want to do a manual enumeration instead of running scripts.
> 
- For example, let's `LinPEAS` from `PEASS` on this Linux system:
```
secmancer@htb[/htb]$ ./linpeas.sh
...SNIP...

Linux Privesc Checklist: https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist
 LEYEND:
  RED/YELLOW: 99% a PE vector
  RED: You must take a look at it
  LightCyan: Users with console
  Blue: Users without console & mounted devs
  Green: Common things (users, groups, SUID/SGID, mounts, .sh scripts, cronjobs)
  LightMangenta: Your username


====================================( Basic information )=====================================
OS: Linux version 3.9.0-73-generic
User & Groups: uid=33(www-data) gid=33(www-data) groups=33(www-data)
...SNIP...
```
- After running, it gives us a great report on the possible vulnerabilities to look into.


### Kernel Exploits
- Now that we have an idea of potential vulnerabilities, we can start looking for potential exploits for them.
- We can use tools like `searchsploit` to find what we need.
- For example, the above system is vulnerable to `CVE-2016-5195`, or `DirtyCow`. We can use searchsploit to find a working exploit for `DirtyCow` and run it on our server to gain root access.
- We can do something similar for Windows as well.

> Note: kernel exploits can cause system instability, so great caution should be taken before running them on systems proven critical, like production systems. Therefore, it's recommended to get approval on them first from the client before doing anything else.


### Vulnerable Software
- Installed software can also be a great hotspot for vulnerabilities.
- For example, we can find installed software by doing:
	- `dpkg -l` on Linux systems that use the apt package manager
	- `C:\Program Files` on Windows machines
- We can also look for public exploits that may exist for existing software as well, especially if older versions are installed.

### User Privileges
- After getting access, it's good to know what specific commands can be ran as root, or another user if that is the case. This way, we can specifically find an exploit to use.
- Common ways to exploit certain user privileges include:
	1. Sudo
	2. SUID
	3. Windows Token Privileges
- Sudo on Linux allows users to execute commands as a different user. Usually lower privileged users use it to execute commands as root without having to use the root user. 
- Specific commands, like `tcpdump`, need sudo to be able to function properly, or be able to access certain, root-only directories.
- We can check sudo privileges using the `sudo -l` command:
```
secmancer@htb[/htb]$ sudo -l

[sudo] password for user1:
...SNIP...

User user1 may run the following commands on ExampleServer:
    (ALL : ALL) ALL
```
- Above, we see we can run any command as sudo, so we can go ahead and use the `su` command to switch to the root user:
```
secmancer@htb[/htb]$ sudo su -

[sudo] password for user1:
whoami
root
```
- Note that the above command requires a password to run any commands with `sudo`. 
- Most of the time,  we may be only allowed to execute certain applications without a password.
```
secmancer@htb[/htb]$ sudo -l

    (user : user) NOPASSWD: /bin/echo
```
- The `NOPASSWD` entry shows that `/bin/echo`can be executed without a password.
- This is useful in using that command to attempt to whatever we want to do as the root user, as shown below:
```
secmancer@htb[/htb]$ sudo -u user /bin/echo Hello World!

    Hello World!
```
- 

- Once we find a particular application we can run with `sudo`, we can look for ways to exploit it to get a shell as the root user. [GTFOBins](https://gtfobins.github.io) contains a list of commands and how they can be exploited through `sudo`. 
- We can search for the application we have `sudo` privilege over, and if it exists, it may tell us the exact command we should execute to gain root access using the `sudo` privilege we have.
- [LOLBAS](https://lolbas-project.github.io/#) also contains a list of Windows applications which we may be able to leverage to perform certain functions, like downloading files or executing commands in the context of a privileged user.


### Scheduled Tasks
- In both Linux and Windows, there are methods to have scripts run at specific intervals to carry out a task. 
- Some examples are having an anti-virus scan running every hour or a backup script that runs every 30 minutes. 
- There are usually two ways to take advantage of scheduled tasks (Windows) or cron jobs (Linux) to escalate our privileges:
	1. Add new scheduled tasks/cron jobs
	2. Trick them to execute a malicious software
- The easiest way is to check if we are allowed to add new scheduled tasks. 
- In Linux, a common form of maintaining scheduled tasks is through `Cron Jobs`. 
- There are specific directories that we may be able to utilize to add new cron jobs if we have the `write` permissions over them. These include:
	1. `/etc/crontab`
	2. `/etc/cron.d`
	3. `/var/spool/cron/crontabs/root`
- If we can write to a directory called by a cron job, we can write a bash script with a reverse shell command, which should send us a reverse shell when executed.

### Exposed Credentials
- Next, we can look for files we can read and see if they contain any exposed credentials. This is very common with `configuration` files, `log` files, and user history files (`bash_history` in Linux and `PSReadLine` in Windows). 
- The enumeration scripts we discussed at the beginning usually look for potential passwords in files and provide them to us, as below:
```
...SNIP...
[+] Searching passwords in config PHP files
[+] Finding passwords inside logs (limit 70)
...SNIP...
/var/www/html/config.php: $conn = new mysqli(localhost, 'db_user', 'password123');
```
- As we can see, the database password '`password123`' is exposed, which would allow us to log in to the local `mysql` databases and look for interesting information. 
- We may also check for `Password Reuse`, as the system user may have used their password for the databases, which may allow us to use the same password to switch to that user, as follows:
```
secmancer@htb[/htb]$ su -

Password: password123
whoami

root
```
- We may also use the user credentials to `ssh` into the server as that user.


### SSH Keys
- Finally, let us discuss SSH keys. If we have read access over the `.ssh` directory for a specific user, we may read their private ssh keys found in `/home/user/.ssh/id_rsa` or `/root/.ssh/id_rsa`, and use it to log in to the server. 
- If we can read the `/root/.ssh/` directory and can read the `id_rsa` file, we can copy it to our machine and use the `-i` flag to log in with it:
```
secmancer@htb[/htb]$ vim id_rsa
secmancer@htb[/htb]$ chmod 600 id_rsa
secmancer@htb[/htb]$ ssh root@10.10.10.10 -i id_rsa

root@10.10.10.10#
```

> Note that we used the command 'chmod 600 id_rsa' on the key after we created it on our machine to change the file's permissions to be more restrictive. If ssh keys have lax permissions, i.e., maybe read by other people, the ssh server would prevent them from working.

- If we find ourselves with write access to a users`/.ssh/` directory, we can place our public key in the user's ssh directory at `/home/user/.ssh/authorized_keys`. 
- This technique is usually used to gain ssh access after gaining a shell as that user. 
- The current SSH configuration will not accept keys written by other users, so it will only work if we have already gained control over that user. 
- We must first create a new key with `ssh-keygen` and the `-f` flag to specify the output file:

```
secmancer@htb[/htb]$ ssh-keygen -f key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): *******
Enter same passphrase again: *******

Your identification has been saved in key
Your public key has been saved in key.pub
The key fingerprint is:
SHA256:...SNIP... user@parrot
The key's randomart image is:
+---[RSA 3072]----+
|   ..o.++.+      |
...SNIP...
|     . ..oo+.    |
+----[SHA256]-----+
```

- This will give us two files: `key` (which we will use with `ssh -i`) and `key.pub`, which we will copy to the remote machine. Let us copy `key.pub`, then on the remote machine, we will add it into `/root/.ssh/authorized_keys`:

```
user@remotehost$ echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```

- Now, the remote server should allow us to log in as that user by using our private key:

```
secmancer@htb[/htb]$ ssh root@10.10.10.10 -i key

root@remotehost# 
```

- As we can see, we can now ssh in as the user `root`. 
- The [Linux Privilege Escalation](https://academy.hackthebox.com/module/details/51) and the [Windows Privilege Escalation](https://academy.hackthebox.com/module/details/67) modules go into more details on how to use each of these methods for Privilege Escalation, and many others as well.

### Questions
- SSH into the server above with the provided credentials, and use the '-p xxxxxx' to specify the port shown above. Once you login, try to find a way to move to 'user2', to get the flag in '/home/user2/flag.txt'.
	- HTB{l473r4l_m0v3m3n7_70_4n07h3r_u53r}
- Once you gain access to 'user2', try to find a way to escalate your privileges to root, to get the flag in '/root/flag.txt'.
	- HTB{pr1v1l363_35c4l4710n_2_r007}